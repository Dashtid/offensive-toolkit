#!/usr/bin/env python3
"""
Lateral Movement Scanner - Network Pivot Detection

Scans for lateral movement opportunities in authorized environments.

[!] AUTHORIZATION REQUIRED: Only use on authorized networks.
[!] ETHICAL USE ONLY: For defensive training and authorized security testing.

Usage:
    python lateral_movement.py --target 192.168.1.0/24 --scan smb,rdp
    python lateral_movement.py --targets-file hosts.txt --scan all

Examples:
    # Scan network for SMB/RDP
    python lateral_movement.py --target 192.168.1.0/24 --scan smb,rdp

    # Full scan with multiple protocols
    python lateral_movement.py --target 10.0.0.0/24 --scan all

    # Scan from file
    python lateral_movement.py --targets-file discovered_hosts.txt --scan all

Author: David Dashti
Date: 2025-10-15
MITRE ATT&CK: T1021 (Remote Services), T1570 (Lateral Tool Transfer), T1550 (Use Alternate Authentication Material)
"""

import argparse
import concurrent.futures
import json
import socket
import subprocess
import sys
from datetime import datetime
from ipaddress import IPv4Network
from pathlib import Path
from typing import Any

from offensive_toolkit.utils.config import load_config
from offensive_toolkit.utils.helpers import RateLimiter
from offensive_toolkit.utils.logger import get_logger

logger = get_logger(__name__)


class LateralMovementScanner:
    """
    Scan for lateral movement opportunities.

    Tests network services commonly used for lateral movement.
    """

    # Common ports for lateral movement
    PORTS = {
        "smb": [445, 139],
        "rdp": [3389],
        "ssh": [22],
        "winrm": [5985, 5986],
        "wmi": [135],
        "vnc": [5900, 5901, 5902],
        "telnet": [23],
    }

    def __init__(self, config: dict[str, Any] | None = None) -> None:
        """Initialize lateral movement scanner."""
        self.config = config or load_config()
        self.rate_limiter = RateLimiter(
            self.config.get("rate_limit", {}).get("requests_per_second", 10)
        )
        self.findings = {"hosts": [], "services": [], "shares": [], "vulnerabilities": []}
        logger.info("Initialized LateralMovementScanner")

    def scan_host(self, ip: str, protocols: list[str]) -> dict[str, Any]:
        """
        Scan a single host for lateral movement opportunities.

        Args:
            ip: Target IP address
            protocols: List of protocols to test

        Returns:
            Scan results for host
        """
        self.rate_limiter.wait()

        logger.debug(f"Scanning {ip}...")

        host_result = {"ip": ip, "open_ports": [], "services": [], "accessible": False}

        # Scan each protocol
        for protocol in protocols:
            ports = self.PORTS.get(protocol, [])

            for port in ports:
                if self._check_port(ip, port):
                    host_result["open_ports"].append({"port": port, "protocol": protocol})
                    host_result["accessible"] = True

                    # Get service details
                    service_info = self._identify_service(ip, port, protocol)
                    if service_info:
                        host_result["services"].append(service_info)

        return host_result

    def _check_port(self, ip: str, port: int, timeout: int = 2) -> bool:
        """Check if port is open."""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((ip, port))
            sock.close()
            return result == 0
        except Exception as e:
            logger.debug(f"Error checking {ip}:{port}: {e}")
            return False

    def _identify_service(self, ip: str, port: int, protocol: str) -> dict[str, Any] | None:
        """Identify service details."""
        service_info = {"ip": ip, "port": port, "protocol": protocol, "details": {}}

        try:
            # Banner grabbing
            if protocol in ["ssh", "telnet", "vnc"]:
                banner = self._grab_banner(ip, port)
                if banner:
                    service_info["details"]["banner"] = banner

            # SMB enumeration
            elif protocol == "smb":
                smb_info = self._enumerate_smb(ip)
                if smb_info:
                    service_info["details"].update(smb_info)

            # RDP detection
            elif protocol == "rdp":
                service_info["details"]["rdp_available"] = True

            return service_info

        except Exception as e:
            logger.debug(f"Error identifying service {ip}:{port}: {e}")
            return service_info

    def _grab_banner(self, ip: str, port: int, timeout: int = 3) -> str | None:
        """Grab service banner."""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            sock.connect((ip, port))

            # Send minimal request
            sock.send(b"\r\n")

            # Receive banner
            banner = sock.recv(1024).decode("utf-8", errors="ignore").strip()
            sock.close()

            return banner if banner else None

        except Exception as e:
            logger.debug(f"Banner grab failed for {ip}:{port}: {e}")
            return None

    def _enumerate_smb(self, ip: str) -> dict[str, Any] | None:
        """Enumerate SMB shares (Windows/Linux)."""
        smb_info = {}

        try:
            # Try to enumerate shares using net view (Windows) or smbclient (Linux)
            if sys.platform.startswith("win"):
                result = subprocess.run(
                    ["net", "view", f"\\\\{ip}"],
                    check=False,
                    capture_output=True,
                    text=True,
                    timeout=10,
                )

                if result.returncode == 0:
                    # Parse shares
                    shares = []
                    for line in result.stdout.split("\n"):
                        if "Disk" in line or "ADMIN$" in line or "C$" in line:
                            share_name = line.split()[0]
                            shares.append(share_name)

                    smb_info["shares"] = shares
                    smb_info["share_count"] = len(shares)

            else:
                # Linux: Try smbclient if available
                try:
                    result = subprocess.run(
                        ["smbclient", "-L", ip, "-N"],
                        check=False,
                        capture_output=True,
                        text=True,
                        timeout=10,
                    )

                    if result.returncode == 0:
                        shares = []
                        for line in result.stdout.split("\n"):
                            if "Disk" in line:
                                parts = line.split()
                                if parts:
                                    shares.append(parts[0])

                        smb_info["shares"] = shares
                        smb_info["share_count"] = len(shares)

                except FileNotFoundError:
                    logger.debug("smbclient not available")

        except subprocess.TimeoutExpired:
            logger.debug(f"SMB enumeration timeout for {ip}")
        except Exception as e:
            logger.debug(f"SMB enumeration error for {ip}: {e}")

        return smb_info if smb_info else None

    def scan_network(self, targets: list[str], protocols: list[str], max_workers: int = 10) -> None:
        """
        Scan multiple hosts for lateral movement opportunities.

        Args:
            targets: List of target IPs or CIDR ranges
            protocols: List of protocols to scan
            max_workers: Maximum concurrent workers
        """
        logger.info(f"Scanning {len(targets)} targets for lateral movement opportunities...")

        # Expand CIDR ranges
        all_ips = []
        for target in targets:
            if "/" in target:
                # CIDR range
                try:
                    network = IPv4Network(target, strict=False)
                    all_ips.extend([str(ip) for ip in network.hosts()])
                except Exception as e:
                    logger.error(f"Invalid CIDR range {target}: {e}")
            else:
                # Single IP
                all_ips.append(target)

        logger.info(f"Total IPs to scan: {len(all_ips)}")

        # Scan hosts concurrently
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_ip = {executor.submit(self.scan_host, ip, protocols): ip for ip in all_ips}

            for future in concurrent.futures.as_completed(future_to_ip):
                ip = future_to_ip[future]
                try:
                    result = future.result()

                    if result["accessible"]:
                        self.findings["hosts"].append(result)

                        # Add services
                        for service in result["services"]:
                            self.findings["services"].append(service)

                            # Check for vulnerabilities
                            vuln = self._check_vulnerabilities(service)
                            if vuln:
                                self.findings["vulnerabilities"].append(vuln)

                except Exception as e:
                    logger.error(f"Error scanning {ip}: {e}")

    def _check_vulnerabilities(self, service: dict[str, Any]) -> dict[str, Any] | None:
        """Check for common vulnerabilities."""
        vulns = []

        # SMB vulnerabilities
        if service["protocol"] == "smb":
            if service["port"] == 445:
                vulns.append(
                    {
                        "type": "smb_available",
                        "severity": "medium",
                        "description": f"SMB service accessible on {service['ip']}:445",
                        "exploitation": "Test for EternalBlue, anonymous access, weak credentials",
                        "mitre": "T1021.002",
                    }
                )

            # Check for null session
            if "shares" in service.get("details", {}):
                vulns.append(
                    {
                        "type": "smb_enumeration",
                        "severity": "medium",
                        "description": f"SMB shares enumerated on {service['ip']}",
                        "shares": service["details"]["shares"],
                        "mitre": "T1021.002",
                    }
                )

        # RDP vulnerabilities
        elif service["protocol"] == "rdp":
            vulns.append(
                {
                    "type": "rdp_available",
                    "severity": "medium",
                    "description": f"RDP service accessible on {service['ip']}:3389",
                    "exploitation": "Test for BlueKeep (CVE-2019-0708), weak credentials",
                    "mitre": "T1021.001",
                }
            )

        # SSH
        elif service["protocol"] == "ssh":
            banner = service.get("details", {}).get("banner", "")
            if banner:
                vulns.append(
                    {
                        "type": "ssh_available",
                        "severity": "low",
                        "description": f"SSH service on {service['ip']}:{service['port']}",
                        "banner": banner,
                        "exploitation": "Test for weak credentials, key reuse",
                        "mitre": "T1021.004",
                    }
                )

        return vulns[0] if vulns else None

    def get_summary(self) -> dict[str, Any]:
        """Generate summary of findings."""
        return {
            "total_hosts": len(self.findings["hosts"]),
            "accessible_services": len(self.findings["services"]),
            "vulnerabilities": len(self.findings["vulnerabilities"]),
            "by_protocol": self._count_by_protocol(),
        }

    def _count_by_protocol(self) -> dict[str, int]:
        """Count services by protocol."""
        counts = {}
        for service in self.findings["services"]:
            protocol = service["protocol"]
            counts[protocol] = counts.get(protocol, 0) + 1
        return counts

    def save_results(self, output_path: Path) -> None:
        """Save scan results to JSON file."""
        results = {
            "scan_type": "Lateral Movement",
            "timestamp": datetime.now().isoformat(),
            "summary": self.get_summary(),
            "findings": self.findings,
        }

        try:
            with open(output_path, "w") as f:
                json.dump(results, f, indent=2)
            logger.info(f"Results saved to {output_path}")
        except Exception as e:
            logger.error(f"Error saving results: {e}")


def main() -> int:
    """Main entry point for command-line usage."""
    parser = argparse.ArgumentParser(
        description="Lateral Movement Scanner\n[!] For authorized security testing only",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument("--target", help="Target IP or CIDR range (e.g., 192.168.1.0/24)")

    parser.add_argument(
        "--targets-file", type=Path, help="File containing target IPs (one per line)"
    )

    parser.add_argument(
        "--scan",
        default="all",
        help="Protocols to scan (comma-separated): all, smb, rdp, ssh, winrm, wmi, vnc, telnet",
    )

    parser.add_argument("--output", type=Path, help="Output file for findings (JSON)")

    parser.add_argument(
        "--workers", type=int, default=10, help="Maximum concurrent workers (default: 10)"
    )

    parser.add_argument("--config", help="Path to configuration file")

    args = parser.parse_args()

    if not args.target and not args.targets_file:
        parser.error("Either --target or --targets-file is required")

    # Load configuration
    config = load_config(args.config) if args.config else load_config()

    print("\n" + "=" * 70)
    print("[!] Lateral Movement Scanner")
    print("[!] For Authorized Security Testing Only")
    print("=" * 70 + "\n")

    # Collect targets
    targets = []
    if args.target:
        targets.append(args.target)

    if args.targets_file:
        try:
            with open(args.targets_file) as f:
                targets.extend([line.strip() for line in f if line.strip()])
        except FileNotFoundError:
            print(f"[-] Error: File {args.targets_file} not found")
            return 1

    # Determine protocols
    if args.scan == "all":
        protocols = ["smb", "rdp", "ssh", "winrm", "wmi", "vnc", "telnet"]
    else:
        protocols = [p.strip() for p in args.scan.split(",")]

    # Initialize scanner
    scanner = LateralMovementScanner(config)

    # Run scan
    print(f"[*] Scanning {len(targets)} target(s) for protocols: {', '.join(protocols)}")
    print(f"[*] Using {args.workers} concurrent workers\n")

    scanner.scan_network(targets, protocols, args.workers)

    # Get summary
    summary = scanner.get_summary()

    print("\n[+] Scan Complete!")
    print(f"    Accessible Hosts: {summary['total_hosts']}")
    print(f"    Services Found: {summary['accessible_services']}")
    print(f"    Vulnerabilities: {summary['vulnerabilities']}")

    if summary["by_protocol"]:
        print("\n[+] By Protocol:")
        for protocol, count in summary["by_protocol"].items():
            print(f"    {protocol.upper()}: {count}")

    # Print findings
    if summary["total_hosts"] > 0:
        print("\n[+] Accessible Hosts:\n")

        for host in scanner.findings["hosts"][:10]:  # Show first 10
            print(f"    {host['ip']}")
            for port_info in host["open_ports"]:
                print(f"      - {port_info['protocol'].upper()} on port {port_info['port']}")

        if len(scanner.findings["hosts"]) > 10:
            print(f"\n    ... and {len(scanner.findings['hosts']) - 10} more hosts")

    # Save results
    if args.output:
        scanner.save_results(args.output)
        print(f"\n[+] Results saved to {args.output}")

    return 0


if __name__ == "__main__":
    sys.exit(main())
