#!/usr/bin/env python3
"""
Windows Privilege Escalation Scanner

Scans for common Windows privilege escalation opportunities and misconfigurations.

[!] AUTHORIZATION REQUIRED: Only use on authorized systems.
[!] ETHICAL USE ONLY: For defensive training and authorized security testing.

Usage:
    python privesc_windows.py --scan all
    python privesc_windows.py --scan services,registry --output findings.json

Examples:
    # Scan all categories
    python privesc_windows.py --scan all

    # Scan specific categories
    python privesc_windows.py --scan services,permissions,registry

    # Export findings
    python privesc_windows.py --scan all --output privesc_findings.json

Author: David Dashti
Date: 2025-10-15
MITRE ATT&CK: T1068 (Exploitation for Privilege Escalation), T1574 (Hijack Execution Flow),
              T1548 (Abuse Elevation Control Mechanism)
"""

import argparse
import json
import os
import re
import subprocess
import sys
import winreg
from datetime import datetime
from pathlib import Path
from typing import Any

from offensive_toolkit.utils.config import load_config
from offensive_toolkit.utils.logger import get_logger

logger = get_logger(__name__)


class WindowsPrivescScanner:
    """
    Scan for Windows privilege escalation opportunities.

    Checks for common misconfigurations and vulnerabilities.
    """

    def __init__(self, config: dict[str, Any] | None = None) -> None:
        """Initialize Windows privilege escalation scanner."""
        self.config = config or load_config()
        self.findings = {
            "services": [],
            "permissions": [],
            "registry": [],
            "scheduled_tasks": [],
            "tokens": [],
            "kernel": [],
        }
        logger.info("Initialized WindowsPrivescScanner")

    def scan_all(self) -> dict[str, list[dict[str, Any]]]:
        """
        Run all privilege escalation checks.

        Returns:
            Dictionary of findings by category
        """
        logger.info("Starting comprehensive Windows privilege escalation scan...")

        self.scan_unquoted_service_paths()
        self.scan_weak_service_permissions()
        self.scan_registry_autorun()
        self.scan_alwaysinstallelevated()
        self.scan_weak_file_permissions()
        self.scan_scheduled_tasks()
        self.scan_token_privileges()
        self.scan_autologon_credentials()
        self.suggest_kernel_exploits()

        logger.info("Privilege escalation scan complete")
        return self.findings

    def scan_unquoted_service_paths(self) -> None:
        """Scan for services with unquoted paths containing spaces."""
        logger.info("Scanning for unquoted service paths...")

        try:
            result = subprocess.run(
                ["wmic", "service", "get", "name,pathname,displayname,startmode"],
                check=False,
                capture_output=True,
                text=True,
            )

            if result.returncode != 0:
                logger.error("Failed to enumerate services")
                return

            lines = result.stdout.split("\n")[1:]  # Skip header

            for line in lines:
                line = line.strip()
                if not line:
                    continue

                # Parse service information
                parts = line.split()
                if len(parts) < 3:
                    continue

                # Extract pathname (may contain spaces)
                match = re.search(r'([A-Za-z]:\\[^"]+\.exe)', line)
                if match:
                    pathname = match.group(1)

                    # Check if path contains spaces and is unquoted
                    if " " in pathname and not line.startswith('"'):
                        # Extract service name
                        service_name = parts[0] if parts else "Unknown"

                        self.findings["services"].append(
                            {
                                "type": "unquoted_service_path",
                                "service": service_name,
                                "path": pathname,
                                "severity": "medium",
                                "description": f"Service '{service_name}' has unquoted path with spaces",
                                "exploitation": "Place malicious executable in path to hijack service",
                                "mitre": "T1574.009",
                            }
                        )

        except Exception as e:
            logger.error(f"Error scanning unquoted service paths: {e}")

    def scan_weak_service_permissions(self) -> None:
        """Scan for services with weak permissions."""
        logger.info("Scanning for weak service permissions...")

        try:
            # Get list of services
            result = subprocess.run(
                ["sc", "query", "type=", "service", "state=", "all"],
                check=False,
                capture_output=True,
                text=True,
            )

            if result.returncode != 0:
                return

            # Extract service names
            service_names = re.findall(r"SERVICE_NAME:\s+(.+)", result.stdout)

            for service_name in service_names[:20]:  # Limit to first 20 for performance
                # Check service permissions
                perm_result = subprocess.run(
                    ["sc", "sdshow", service_name], check=False, capture_output=True, text=True
                )

                if perm_result.returncode == 0:
                    sddl = perm_result.stdout.strip()

                    # Check for weak permissions (e.g., Everyone, Authenticated Users)
                    if "WD" in sddl or "AU" in sddl:  # WD=Everyone, AU=Authenticated Users
                        # Get service config
                        config_result = subprocess.run(
                            ["sc", "qc", service_name], check=False, capture_output=True, text=True
                        )

                        self.findings["services"].append(
                            {
                                "type": "weak_service_permissions",
                                "service": service_name,
                                "sddl": sddl,
                                "severity": "high",
                                "description": f"Service '{service_name}' has weak permissions",
                                "exploitation": "Modify service binary path or configuration",
                                "mitre": "T1574.010",
                            }
                        )

        except Exception as e:
            logger.error(f"Error scanning service permissions: {e}")

    def scan_registry_autorun(self) -> None:
        """Scan registry autorun locations for weak permissions."""
        logger.info("Scanning registry autorun locations...")

        autorun_keys = [
            (winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\CurrentVersion\Run"),
            (winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\CurrentVersion\RunOnce"),
            (winreg.HKEY_LOCAL_MACHINE, r"Software\Microsoft\Windows\CurrentVersion\Run"),
            (winreg.HKEY_LOCAL_MACHINE, r"Software\Microsoft\Windows\CurrentVersion\RunOnce"),
        ]

        for hive, key_path in autorun_keys:
            try:
                key = winreg.OpenKey(hive, key_path, 0, winreg.KEY_READ)

                i = 0
                while True:
                    try:
                        name, value, _ = winreg.EnumValue(key, i)

                        self.findings["registry"].append(
                            {
                                "type": "registry_autorun",
                                "hive": "HKCU" if hive == winreg.HKEY_CURRENT_USER else "HKLM",
                                "key": key_path,
                                "name": name,
                                "value": value,
                                "severity": "info",
                                "description": f"Autorun entry: {name}",
                                "mitre": "T1547.001",
                            }
                        )

                        i += 1
                    except OSError:
                        break

                winreg.CloseKey(key)

            except FileNotFoundError:
                continue
            except Exception as e:
                logger.debug(f"Error reading registry key {key_path}: {e}")

    def scan_alwaysinstallelevated(self) -> None:
        """Check if AlwaysInstallElevated is enabled."""
        logger.info("Checking AlwaysInstallElevated...")

        try:
            # Check both HKLM and HKCU
            hklm_key = winreg.OpenKey(
                winreg.HKEY_LOCAL_MACHINE,
                r"SOFTWARE\Policies\Microsoft\Windows\Installer",
                0,
                winreg.KEY_READ,
            )

            hklm_value, _ = winreg.QueryValueEx(hklm_key, "AlwaysInstallElevated")
            winreg.CloseKey(hklm_key)

            hkcu_key = winreg.OpenKey(
                winreg.HKEY_CURRENT_USER,
                r"SOFTWARE\Policies\Microsoft\Windows\Installer",
                0,
                winreg.KEY_READ,
            )

            hkcu_value, _ = winreg.QueryValueEx(hkcu_key, "AlwaysInstallElevated")
            winreg.CloseKey(hkcu_key)

            if hklm_value == 1 and hkcu_value == 1:
                self.findings["registry"].append(
                    {
                        "type": "alwaysinstallelevated",
                        "severity": "critical",
                        "description": "AlwaysInstallElevated is enabled (HKLM and HKCU)",
                        "exploitation": "MSI packages run with SYSTEM privileges",
                        "mitre": "T1548.002",
                    }
                )

        except FileNotFoundError:
            pass  # Keys don't exist - not vulnerable
        except Exception as e:
            logger.debug(f"Error checking AlwaysInstallElevated: {e}")

    def scan_weak_file_permissions(self) -> None:
        """Scan for weak file/folder permissions in common locations."""
        logger.info("Scanning for weak file permissions...")

        # Common locations to check
        check_paths = [
            r"C:\Program Files",
            r"C:\Program Files (x86)",
            r"C:\Windows\System32",
            r"C:\Windows\Temp",
        ]

        for path in check_paths:
            if not os.path.exists(path):
                continue

            try:
                # Check if current user can write to directory
                test_file = os.path.join(path, "test_write_access.tmp")

                try:
                    with open(test_file, "w") as f:
                        f.write("test")
                    os.remove(test_file)

                    self.findings["permissions"].append(
                        {
                            "type": "weak_directory_permissions",
                            "path": path,
                            "severity": "high",
                            "description": f"Current user has write access to {path}",
                            "exploitation": "Place malicious DLLs or executables for hijacking",
                            "mitre": "T1574.001",
                        }
                    )

                except PermissionError:
                    pass  # Expected - no write access

            except Exception as e:
                logger.debug(f"Error checking {path}: {e}")

    def scan_scheduled_tasks(self) -> None:
        """Scan for scheduled tasks with weak permissions."""
        logger.info("Scanning scheduled tasks...")

        try:
            result = subprocess.run(
                ["schtasks", "/query", "/fo", "LIST", "/v"],
                check=False,
                capture_output=True,
                text=True,
            )

            if result.returncode != 0:
                return

            lines = result.stdout.split("\n")
            current_task = {}

            for line in lines:
                line = line.strip()

                if line.startswith("TaskName:"):
                    if current_task:
                        # Check if task has interesting properties
                        if current_task.get("run_as_user") in ["SYSTEM", "NT AUTHORITY\\SYSTEM"]:
                            self.findings["scheduled_tasks"].append(current_task)

                    current_task = {
                        "type": "scheduled_task",
                        "name": line.split(":", 1)[1].strip(),
                        "severity": "medium",
                    }

                elif line.startswith("Task To Run:") and current_task:
                    current_task["command"] = line.split(":", 1)[1].strip()

                elif line.startswith("Run As User:") and current_task:
                    current_task["run_as_user"] = line.split(":", 1)[1].strip()

                elif line.startswith("Status:") and current_task:
                    current_task["status"] = line.split(":", 1)[1].strip()

            if current_task and current_task.get("run_as_user") in [
                "SYSTEM",
                "NT AUTHORITY\\SYSTEM",
            ]:
                self.findings["scheduled_tasks"].append(current_task)

        except Exception as e:
            logger.error(f"Error scanning scheduled tasks: {e}")

    def scan_token_privileges(self) -> None:
        """Check current token privileges."""
        logger.info("Checking token privileges...")

        try:
            result = subprocess.run(
                ["whoami", "/priv"], check=False, capture_output=True, text=True
            )

            if result.returncode != 0:
                return

            dangerous_privileges = [
                "SeImpersonatePrivilege",
                "SeAssignPrimaryTokenPrivilege",
                "SeDebugPrivilege",
                "SeTcbPrivilege",
                "SeBackupPrivilege",
                "SeRestorePrivilege",
                "SeTakeOwnershipPrivilege",
            ]

            for priv in dangerous_privileges:
                if priv in result.stdout and "Enabled" in result.stdout:
                    self.findings["tokens"].append(
                        {
                            "type": "dangerous_privilege",
                            "privilege": priv,
                            "severity": "high",
                            "description": f"Current user has {priv} enabled",
                            "exploitation": "Can be used for privilege escalation",
                            "mitre": "T1134",
                        }
                    )

        except Exception as e:
            logger.error(f"Error checking privileges: {e}")

    def scan_autologon_credentials(self) -> None:
        """Check for autologon credentials in registry."""
        logger.info("Checking for autologon credentials...")

        try:
            key = winreg.OpenKey(
                winreg.HKEY_LOCAL_MACHINE,
                r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon",
                0,
                winreg.KEY_READ,
            )

            try:
                username, _ = winreg.QueryValueEx(key, "DefaultUserName")
                password, _ = winreg.QueryValueEx(key, "DefaultPassword")

                if username and password:
                    self.findings["registry"].append(
                        {
                            "type": "autologon_credentials",
                            "severity": "critical",
                            "username": username,
                            "description": "Autologon credentials found in registry",
                            "mitre": "T1552.002",
                        }
                    )

            except FileNotFoundError:
                pass  # No autologon configured

            winreg.CloseKey(key)

        except Exception as e:
            logger.debug(f"Error checking autologon credentials: {e}")

    def suggest_kernel_exploits(self) -> None:
        """Suggest kernel exploits based on Windows version."""
        logger.info("Checking for kernel exploit suggestions...")

        try:
            result = subprocess.run(["systeminfo"], check=False, capture_output=True, text=True)

            if result.returncode != 0:
                return

            # Extract OS version and hotfixes
            os_name = re.search(r"OS Name:\s+(.+)", result.stdout)
            os_version = re.search(r"OS Version:\s+(.+)", result.stdout)

            if os_name and os_version:
                os_info = f"{os_name.group(1).strip()} {os_version.group(1).strip()}"

                # Simple exploit suggestions based on version
                exploit_db = {
                    "Windows 7": ["MS16-032", "MS16-034", "MS16-135"],
                    "Windows 8": ["MS16-032", "MS16-034"],
                    "Windows 10": ["CVE-2021-1732", "CVE-2021-36934 (HiveNightmare)"],
                    "Windows Server 2008": ["MS16-032", "MS15-051"],
                    "Windows Server 2012": ["MS16-032"],
                }

                for version, exploits in exploit_db.items():
                    if version in os_info:
                        self.findings["kernel"].append(
                            {
                                "type": "kernel_exploit_suggestion",
                                "os": os_info,
                                "exploits": exploits,
                                "severity": "high",
                                "description": f"Potential kernel exploits for {version}",
                                "mitre": "T1068",
                            }
                        )
                        break

        except Exception as e:
            logger.error(f"Error suggesting kernel exploits: {e}")

    def get_findings_summary(self) -> dict[str, Any]:
        """
        Generate summary of findings.

        Returns:
            Summary dictionary with counts and severity
        """
        total_findings = sum(len(v) for v in self.findings.values())

        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}

        for category in self.findings.values():
            for finding in category:
                severity = finding.get("severity", "info")
                severity_counts[severity] += 1

        return {
            "total_findings": total_findings,
            "by_category": {k: len(v) for k, v in self.findings.items()},
            "by_severity": severity_counts,
        }

    def save_results(self, output_path: Path) -> None:
        """Save findings to JSON file."""
        results = {
            "scan_type": "Windows Privilege Escalation",
            "timestamp": datetime.now().isoformat(),
            "summary": self.get_findings_summary(),
            "findings": self.findings,
        }

        try:
            with open(output_path, "w") as f:
                json.dump(results, f, indent=2)
            logger.info(f"Results saved to {output_path}")
        except Exception as e:
            logger.error(f"Error saving results: {e}")


def main() -> int:
    """Main entry point for command-line usage."""
    parser = argparse.ArgumentParser(
        description="Windows Privilege Escalation Scanner\n"
        "[!] For authorized security testing only",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument(
        "--scan",
        default="all",
        help="Categories to scan (comma-separated): all, services, permissions, registry, tasks, tokens, kernel",
    )

    parser.add_argument("--output", type=Path, help="Output file for findings (JSON)")

    parser.add_argument("--config", help="Path to configuration file")

    args = parser.parse_args()

    # Load configuration
    config = load_config(args.config) if args.config else load_config()

    print("\n" + "=" * 70)
    print("[!] Windows Privilege Escalation Scanner")
    print("[!] For Authorized Security Testing Only")
    print("=" * 70 + "\n")

    # Initialize scanner
    scanner = WindowsPrivescScanner(config)

    # Run scans
    print("[*] Starting privilege escalation scan...")

    if args.scan == "all":
        scanner.scan_all()
    else:
        categories = args.scan.split(",")
        for category in categories:
            category = category.strip()
            if category == "services":
                scanner.scan_unquoted_service_paths()
                scanner.scan_weak_service_permissions()
            elif category == "permissions":
                scanner.scan_weak_file_permissions()
            elif category == "registry":
                scanner.scan_registry_autorun()
                scanner.scan_alwaysinstallelevated()
                scanner.scan_autologon_credentials()
            elif category == "tasks":
                scanner.scan_scheduled_tasks()
            elif category == "tokens":
                scanner.scan_token_privileges()
            elif category == "kernel":
                scanner.suggest_kernel_exploits()

    # Get summary
    summary = scanner.get_findings_summary()

    print("\n[+] Scan Complete!")
    print(f"    Total Findings: {summary['total_findings']}")
    print("\n[+] By Category:")
    for category, count in summary["by_category"].items():
        if count > 0:
            print(f"    {category}: {count}")

    print("\n[+] By Severity:")
    for severity, count in summary["by_severity"].items():
        if count > 0:
            print(f"    {severity.upper()}: {count}")

    # Print detailed findings
    if summary["total_findings"] > 0:
        print("\n[+] Detailed Findings:\n")

        for category, findings in scanner.findings.items():
            if findings:
                print(f"  [{category.upper()}]")
                for finding in findings:
                    print(f"    - {finding.get('type', 'unknown')}")
                    print(f"      Severity: {finding.get('severity', 'unknown').upper()}")
                    print(f"      Description: {finding.get('description', 'N/A')}")
                    if "mitre" in finding:
                        print(f"      MITRE: {finding['mitre']}")
                    print()

    # Save results
    if args.output:
        scanner.save_results(args.output)
        print(f"[+] Results saved to {args.output}")

    return 0


if __name__ == "__main__":
    sys.exit(main())
