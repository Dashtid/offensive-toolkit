#!/usr/bin/env python3
"""
Linux Privilege Escalation Scanner

Scans for common Linux privilege escalation opportunities and misconfigurations.

[!] AUTHORIZATION REQUIRED: Only use on authorized systems.
[!] ETHICAL USE ONLY: For defensive training and authorized security testing.

Usage:
    python privesc_linux.py --scan all
    python privesc_linux.py --scan suid,sudo --output findings.json

Examples:
    # Scan all categories
    python privesc_linux.py --scan all

    # Scan specific categories
    python privesc_linux.py --scan suid,sudo,cron

    # Export findings
    python privesc_linux.py --scan all --output privesc_findings.json

Author: David Dashti
Date: 2025-10-15
MITRE ATT&CK: T1068 (Exploitation for Privilege Escalation), T1548 (Abuse Elevation Control Mechanism),
              T1574 (Hijack Execution Flow)
"""

import argparse
import sys
import subprocess
import os
import stat
import pwd
import grp
from pathlib import Path
from typing import Dict, Any, List, Optional
from datetime import datetime
import json

from utils.logger import get_logger
from utils.config import load_config

logger = get_logger(__name__)


class LinuxPrivescScanner:
    """
    Scan for Linux privilege escalation opportunities.

    Checks for common misconfigurations and vulnerabilities.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None) -> None:
        """Initialize Linux privilege escalation scanner."""
        self.config = config or load_config()
        self.findings = {
            "suid": [],
            "sudo": [],
            "cron": [],
            "writable": [],
            "capabilities": [],
            "kernel": [],
            "containers": []
        }
        self.current_user = os.getenv("USER", "unknown")
        self.current_uid = os.getuid()
        logger.info(f"Initialized LinuxPrivescScanner (user: {self.current_user}, uid: {self.current_uid})")

    def scan_all(self) -> Dict[str, List[Dict[str, Any]]]:
        """
        Run all privilege escalation checks.

        Returns:
            Dictionary of findings by category
        """
        logger.info("Starting comprehensive Linux privilege escalation scan...")

        self.scan_suid_binaries()
        self.scan_sudo_misconfigurations()
        self.scan_cron_jobs()
        self.scan_writable_system_files()
        self.scan_writable_scripts()
        self.scan_capabilities()
        self.scan_docker_escape()
        self.suggest_kernel_exploits()

        logger.info("Privilege escalation scan complete")
        return self.findings

    def scan_suid_binaries(self) -> None:
        """Scan for SUID/SGID binaries."""
        logger.info("Scanning for SUID/SGID binaries...")

        dangerous_suid = [
            "nmap", "vim", "find", "bash", "more", "less", "nano",
            "cp", "mv", "awk", "man", "wget", "curl", "python",
            "perl", "ruby", "lua", "php", "gcc", "docker", "apt",
            "yum", "rpm", "dpkg", "tar", "zip", "unzip"
        ]

        try:
            # Find SUID binaries
            result = subprocess.run(
                ["find", "/", "-type", "f", "-perm", "-4000", "2>/dev/null"],
                capture_output=True,
                text=True,
                shell=True
            )

            suid_files = result.stdout.strip().split("\n")

            for filepath in suid_files:
                if not filepath:
                    continue

                filename = os.path.basename(filepath)

                # Check if it's a dangerous binary
                is_dangerous = any(danger in filename for danger in dangerous_suid)

                self.findings["suid"].append({
                    "type": "suid_binary",
                    "path": filepath,
                    "filename": filename,
                    "severity": "high" if is_dangerous else "medium",
                    "dangerous": is_dangerous,
                    "description": f"SUID binary: {filepath}",
                    "exploitation": "GTFOBins may have exploit techniques" if is_dangerous else "Check for vulnerabilities",
                    "mitre": "T1548.001"
                })

            # Find SGID binaries
            result = subprocess.run(
                ["find", "/", "-type", "f", "-perm", "-2000", "2>/dev/null"],
                capture_output=True,
                text=True,
                shell=True
            )

            sgid_files = result.stdout.strip().split("\n")

            for filepath in sgid_files[:10]:  # Limit output
                if filepath:
                    self.findings["suid"].append({
                        "type": "sgid_binary",
                        "path": filepath,
                        "severity": "low",
                        "description": f"SGID binary: {filepath}",
                        "mitre": "T1548.001"
                    })

        except Exception as e:
            logger.error(f"Error scanning SUID binaries: {e}")

    def scan_sudo_misconfigurations(self) -> None:
        """Check for sudo misconfigurations."""
        logger.info("Scanning sudo configuration...")

        try:
            # Check sudo -l
            result = subprocess.run(
                ["sudo", "-l"],
                capture_output=True,
                text=True
            )

            if result.returncode == 0:
                sudo_output = result.stdout

                # Parse sudo entries
                if "NOPASSWD" in sudo_output:
                    self.findings["sudo"].append({
                        "type": "sudo_nopasswd",
                        "severity": "high",
                        "description": "User has NOPASSWD sudo entries",
                        "output": sudo_output,
                        "exploitation": "Execute commands as root without password",
                        "mitre": "T1548.003"
                    })

                # Check for dangerous sudo entries
                dangerous_commands = ["vim", "less", "more", "nano", "find", "awk", "python", "perl", "ruby", "/bin/sh", "/bin/bash"]

                for cmd in dangerous_commands:
                    if cmd in sudo_output:
                        self.findings["sudo"].append({
                            "type": "sudo_dangerous_command",
                            "command": cmd,
                            "severity": "critical",
                            "description": f"User can run '{cmd}' with sudo",
                            "exploitation": f"GTFOBins: sudo {cmd}",
                            "mitre": "T1548.003"
                        })

        except subprocess.CalledProcessError:
            pass  # No sudo access
        except Exception as e:
            logger.debug(f"Error checking sudo: {e}")

    def scan_cron_jobs(self) -> None:
        """Scan for cron jobs with weak permissions."""
        logger.info("Scanning cron jobs...")

        cron_locations = [
            "/etc/crontab",
            "/etc/cron.d",
            "/etc/cron.daily",
            "/etc/cron.hourly",
            "/etc/cron.weekly",
            "/etc/cron.monthly",
            "/var/spool/cron/crontabs"
        ]

        for location in cron_locations:
            if not os.path.exists(location):
                continue

            try:
                if os.path.isfile(location):
                    # Check file permissions
                    file_stat = os.stat(location)
                    if file_stat.st_mode & stat.S_IWOTH:  # World-writable
                        self.findings["cron"].append({
                            "type": "writable_cron_file",
                            "path": location,
                            "severity": "critical",
                            "description": f"Cron file is world-writable: {location}",
                            "exploitation": "Modify cron job to execute as root",
                            "mitre": "T1053.003"
                        })

                elif os.path.isdir(location):
                    # Check scripts in directory
                    for script in Path(location).iterdir():
                        if script.is_file():
                            script_stat = os.stat(script)
                            if script_stat.st_mode & stat.S_IWOTH:
                                self.findings["cron"].append({
                                    "type": "writable_cron_script",
                                    "path": str(script),
                                    "severity": "high",
                                    "description": f"Cron script is world-writable: {script}",
                                    "exploitation": "Modify script to execute as root",
                                    "mitre": "T1053.003"
                                })

            except PermissionError:
                pass
            except Exception as e:
                logger.debug(f"Error checking {location}: {e}")

    def scan_writable_system_files(self) -> None:
        """Scan for writable system files."""
        logger.info("Scanning for writable system files...")

        critical_files = [
            "/etc/passwd",
            "/etc/shadow",
            "/etc/sudoers",
            "/etc/ssh/sshd_config",
            "/etc/hosts"
        ]

        for filepath in critical_files:
            if not os.path.exists(filepath):
                continue

            try:
                file_stat = os.stat(filepath)

                # Check if writable by current user
                if os.access(filepath, os.W_OK):
                    self.findings["writable"].append({
                        "type": "writable_critical_file",
                        "path": filepath,
                        "severity": "critical",
                        "description": f"Critical file is writable: {filepath}",
                        "exploitation": "Modify system configuration or add privileged user",
                        "mitre": "T1098"
                    })

                # Check if world-writable
                elif file_stat.st_mode & stat.S_IWOTH:
                    self.findings["writable"].append({
                        "type": "world_writable_critical_file",
                        "path": filepath,
                        "severity": "critical",
                        "description": f"Critical file is world-writable: {filepath}",
                        "mitre": "T1098"
                    })

            except Exception as e:
                logger.debug(f"Error checking {filepath}: {e}")

    def scan_writable_scripts(self) -> None:
        """Scan PATH for writable scripts."""
        logger.info("Scanning PATH for writable scripts...")

        path_dirs = os.getenv("PATH", "").split(":")

        for path_dir in path_dirs:
            if not os.path.exists(path_dir):
                continue

            try:
                dir_stat = os.stat(path_dir)

                # Check if directory is writable
                if os.access(path_dir, os.W_OK):
                    self.findings["writable"].append({
                        "type": "writable_path_directory",
                        "path": path_dir,
                        "severity": "high",
                        "description": f"PATH directory is writable: {path_dir}",
                        "exploitation": "Place malicious script in PATH for hijacking",
                        "mitre": "T1574.007"
                    })

            except Exception as e:
                logger.debug(f"Error checking {path_dir}: {e}")

    def scan_capabilities(self) -> None:
        """Scan for dangerous Linux capabilities."""
        logger.info("Scanning for capabilities...")

        try:
            result = subprocess.run(
                ["getcap", "-r", "/", "2>/dev/null"],
                capture_output=True,
                text=True,
                shell=True
            )

            dangerous_caps = ["cap_setuid", "cap_dac_override", "cap_sys_admin"]

            for line in result.stdout.split("\n"):
                if not line:
                    continue

                for cap in dangerous_caps:
                    if cap in line:
                        self.findings["capabilities"].append({
                            "type": "dangerous_capability",
                            "output": line,
                            "capability": cap,
                            "severity": "high",
                            "description": f"Dangerous capability found: {cap}",
                            "exploitation": "Capability can be exploited for privilege escalation",
                            "mitre": "T1548.001"
                        })

        except Exception as e:
            logger.debug(f"Error scanning capabilities: {e}")

    def scan_docker_escape(self) -> None:
        """Check for Docker container escape opportunities."""
        logger.info("Checking Docker escape possibilities...")

        # Check if inside Docker container
        if os.path.exists("/.dockerenv"):
            self.findings["containers"].append({
                "type": "docker_container_detected",
                "severity": "info",
                "description": "Running inside Docker container",
                "mitre": "T1611"
            })

            # Check for privileged mode
            if os.path.exists("/proc/self/status"):
                try:
                    with open("/proc/self/status", "r") as f:
                        status = f.read()
                        if "CapEff:\t0000003fffffffff" in status:
                            self.findings["containers"].append({
                                "type": "privileged_container",
                                "severity": "critical",
                                "description": "Container running in privileged mode",
                                "exploitation": "Container escape possible with full capabilities",
                                "mitre": "T1611"
                            })
                except Exception as e:
                    logger.debug(f"Error checking container status: {e}")

        # Check for docker socket
        if os.path.exists("/var/run/docker.sock"):
            sock_stat = os.stat("/var/run/docker.sock")
            if os.access("/var/run/docker.sock", os.W_OK):
                self.findings["containers"].append({
                    "type": "accessible_docker_socket",
                    "severity": "critical",
                    "description": "Docker socket is accessible",
                    "exploitation": "Full container escape via Docker API",
                    "mitre": "T1611"
                })

    def suggest_kernel_exploits(self) -> None:
        """Suggest kernel exploits based on kernel version."""
        logger.info("Checking for kernel exploit suggestions...")

        try:
            result = subprocess.run(
                ["uname", "-r"],
                capture_output=True,
                text=True
            )

            kernel_version = result.stdout.strip()

            # Simple exploit database
            exploit_db = {
                "Dirty COW": {"versions": ["2.6", "3.", "4.4", "4.8"], "cve": "CVE-2016-5195"},
                "Ubuntu Overlayfs": {"versions": ["3.13", "3.16", "3.19", "4.2"], "cve": "CVE-2015-8660"},
                "Dirty Pipe": {"versions": ["5.8", "5.10", "5.15", "5.16"], "cve": "CVE-2022-0847"},
            }

            for exploit_name, info in exploit_db.items():
                for ver in info["versions"]:
                    if ver in kernel_version:
                        self.findings["kernel"].append({
                            "type": "kernel_exploit_suggestion",
                            "exploit": exploit_name,
                            "cve": info["cve"],
                            "kernel_version": kernel_version,
                            "severity": "critical",
                            "description": f"Kernel may be vulnerable to {exploit_name}",
                            "mitre": "T1068"
                        })
                        break

        except Exception as e:
            logger.error(f"Error checking kernel version: {e}")

    def get_findings_summary(self) -> Dict[str, Any]:
        """
        Generate summary of findings.

        Returns:
            Summary dictionary with counts and severity
        """
        total_findings = sum(len(v) for v in self.findings.values())

        severity_counts = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "info": 0
        }

        for category in self.findings.values():
            for finding in category:
                severity = finding.get("severity", "info")
                severity_counts[severity] += 1

        return {
            "total_findings": total_findings,
            "by_category": {k: len(v) for k, v in self.findings.items()},
            "by_severity": severity_counts
        }

    def save_results(self, output_path: Path) -> None:
        """Save findings to JSON file."""
        results = {
            "scan_type": "Linux Privilege Escalation",
            "timestamp": datetime.now().isoformat(),
            "user": self.current_user,
            "uid": self.current_uid,
            "summary": self.get_findings_summary(),
            "findings": self.findings
        }

        try:
            with open(output_path, "w") as f:
                json.dump(results, f, indent=2)
            logger.info(f"Results saved to {output_path}")
        except Exception as e:
            logger.error(f"Error saving results: {e}")


def main() -> int:
    """Main entry point for command-line usage."""
    parser = argparse.ArgumentParser(
        description="Linux Privilege Escalation Scanner\n"
                    "[!] For authorized security testing only",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument(
        "--scan",
        default="all",
        help="Categories to scan (comma-separated): all, suid, sudo, cron, writable, capabilities, kernel, containers"
    )

    parser.add_argument(
        "--output",
        type=Path,
        help="Output file for findings (JSON)"
    )

    parser.add_argument(
        "--config",
        help="Path to configuration file"
    )

    args = parser.parse_args()

    # Load configuration
    config = load_config(args.config) if args.config else load_config()

    print("\n" + "=" * 70)
    print("[!] Linux Privilege Escalation Scanner")
    print("[!] For Authorized Security Testing Only")
    print("=" * 70 + "\n")

    # Initialize scanner
    scanner = LinuxPrivescScanner(config)

    # Run scans
    print("[*] Starting privilege escalation scan...")

    if args.scan == "all":
        scanner.scan_all()
    else:
        categories = args.scan.split(",")
        for category in categories:
            category = category.strip()
            if category == "suid":
                scanner.scan_suid_binaries()
            elif category == "sudo":
                scanner.scan_sudo_misconfigurations()
            elif category == "cron":
                scanner.scan_cron_jobs()
            elif category == "writable":
                scanner.scan_writable_system_files()
                scanner.scan_writable_scripts()
            elif category == "capabilities":
                scanner.scan_capabilities()
            elif category == "kernel":
                scanner.suggest_kernel_exploits()
            elif category == "containers":
                scanner.scan_docker_escape()

    # Get summary
    summary = scanner.get_findings_summary()

    print(f"\n[+] Scan Complete!")
    print(f"    Total Findings: {summary['total_findings']}")
    print(f"\n[+] By Category:")
    for category, count in summary['by_category'].items():
        if count > 0:
            print(f"    {category}: {count}")

    print(f"\n[+] By Severity:")
    for severity, count in summary['by_severity'].items():
        if count > 0:
            print(f"    {severity.upper()}: {count}")

    # Print detailed findings (top 10)
    if summary['total_findings'] > 0:
        print(f"\n[+] Top Findings:\n")

        count = 0
        for category, findings in scanner.findings.items():
            for finding in findings:
                if count >= 10:
                    break
                print(f"    [{finding.get('severity', 'unknown').upper()}] {finding.get('type', 'unknown')}")
                print(f"      {finding.get('description', 'N/A')}")
                if 'mitre' in finding:
                    print(f"      MITRE: {finding['mitre']}")
                print()
                count += 1
            if count >= 10:
                break

        if summary['total_findings'] > 10:
            print(f"    ... and {summary['total_findings'] - 10} more findings")

    # Save results
    if args.output:
        scanner.save_results(args.output)
        print(f"\n[+] Results saved to {args.output}")

    return 0


if __name__ == "__main__":
    sys.exit(main())
