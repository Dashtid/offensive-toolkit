#!/usr/bin/env python3
"""
Credential Dumper - Ethical Credential Discovery

Discovers and extracts credentials for authorized security testing.

[!] EXTREMELY SENSITIVE: Accesses and extracts credential data.
[!] AUTHORIZATION REQUIRED: Only use on authorized systems with explicit permission.
[!] AUDIT LOGGING: All operations are logged for accountability.

Usage:
    python credential_dump.py --os windows --types saved,browser
    python credential_dump.py --os linux --types ssh,history --output creds.json

Examples:
    # Windows credential discovery
    python credential_dump.py --os windows --types all

    # Linux SSH key discovery
    python credential_dump.py --os linux --types ssh,history

    # Export encrypted results
    python credential_dump.py --os windows --types all --output creds.json --encrypt

Author: David Dashti
Date: 2025-10-15
MITRE ATT&CK: T1555 (Credentials from Password Stores), T1552 (Unsecured Credentials),
              T1087 (Account Discovery)
"""

import argparse
import base64
import json
import os
import re
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Any

from utils.config import load_config
from utils.logger import get_logger

logger = get_logger(__name__)


class CredentialDumper:
    """
    Ethical credential discovery tool.

    Discovers credentials for authorized security testing with strict controls.
    """

    def __init__(self, config: dict[str, Any] | None = None) -> None:
        """Initialize credential dumper."""
        self.config = config or load_config()
        self.credentials = {
            "saved": [],
            "browser": [],
            "wifi": [],
            "ssh": [],
            "history": [],
            "config": [],
            "registry": [],
        }

        # Audit logging
        self._audit_log("Credential dumper initialized")
        logger.warning("SENSITIVE OPERATION: Credential dumper initialized")

    def _audit_log(self, message: str) -> None:
        """Log operation to audit trail."""
        audit_entry = {
            "timestamp": datetime.now().isoformat(),
            "user": os.getenv("USER", os.getenv("USERNAME", "unknown")),
            "operation": message,
        }
        logger.info(f"AUDIT: {json.dumps(audit_entry)}")

    def _sanitize_credential(self, credential: str) -> str:
        """Sanitize credential for safe storage (basic obfuscation)."""
        return base64.b64encode(credential.encode()).decode()

    # ===================
    # WINDOWS CREDENTIAL DISCOVERY
    # ===================

    def dump_windows_saved_credentials(self) -> None:
        """Discover Windows saved credentials."""
        logger.info("Discovering Windows saved credentials...")
        self._audit_log("Windows saved credentials discovery started")

        try:
            # cmdkey /list
            result = subprocess.run(
                ["cmdkey", "/list"], check=False, capture_output=True, text=True
            )

            if result.returncode == 0:
                lines = result.stdout.split("\n")
                current_cred = {}

                for line in lines:
                    line = line.strip()

                    if line.startswith("Target:"):
                        if current_cred:
                            self.credentials["saved"].append(current_cred)
                        current_cred = {
                            "type": "saved_credential",
                            "target": line.split(":", 1)[1].strip(),
                        }
                    elif line.startswith("Type:") and current_cred:
                        current_cred["cred_type"] = line.split(":", 1)[1].strip()
                    elif line.startswith("User:") and current_cred:
                        current_cred["user"] = line.split(":", 1)[1].strip()

                if current_cred:
                    self.credentials["saved"].append(current_cred)

        except Exception as e:
            logger.error(f"Error discovering saved credentials: {e}")

    def dump_windows_wifi_passwords(self) -> None:
        """Discover Windows WiFi passwords."""
        logger.info("Discovering WiFi passwords...")
        self._audit_log("WiFi password discovery started")

        try:
            # Get WiFi profiles
            profiles_result = subprocess.run(
                ["netsh", "wlan", "show", "profiles"], check=False, capture_output=True, text=True
            )

            if profiles_result.returncode == 0:
                # Extract profile names
                profiles = re.findall(r"All User Profile\s+:\s+(.+)", profiles_result.stdout)

                for profile in profiles[:10]:  # Limit to first 10
                    profile = profile.strip()

                    # Get profile details including password
                    detail_result = subprocess.run(
                        ["netsh", "wlan", "show", "profile", profile, "key=clear"],
                        check=False,
                        capture_output=True,
                        text=True,
                    )

                    if detail_result.returncode == 0:
                        password_match = re.search(r"Key Content\s+:\s+(.+)", detail_result.stdout)

                        if password_match:
                            password = password_match.group(1).strip()

                            self.credentials["wifi"].append(
                                {
                                    "type": "wifi_password",
                                    "ssid": profile,
                                    "password": self._sanitize_credential(password),
                                    "password_hint": password[:2] + "*" * (len(password) - 2)
                                    if len(password) > 2
                                    else "***",
                                }
                            )

        except Exception as e:
            logger.error(f"Error discovering WiFi passwords: {e}")

    def dump_windows_registry_credentials(self) -> None:
        """Search Windows registry for credentials."""
        logger.info("Searching registry for credentials...")
        self._audit_log("Registry credential search started")

        # Common registry locations with credentials
        reg_paths = [
            (r"HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings", "ProxyUser"),
            (r"HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon", "DefaultPassword"),
            (r"HKCU\Software\SimonTatham\PuTTY\Sessions", None),  # PuTTY sessions
        ]

        for reg_path, value_name in reg_paths:
            try:
                if value_name:
                    # Query specific value
                    result = subprocess.run(
                        ["reg", "query", reg_path, "/v", value_name],
                        check=False,
                        capture_output=True,
                        text=True,
                    )

                    if result.returncode == 0 and "REG_SZ" in result.stdout:
                        self.credentials["registry"].append(
                            {
                                "type": "registry_credential",
                                "path": reg_path,
                                "value_name": value_name,
                                "data": "[REDACTED - use --show-passwords to view]",
                            }
                        )
                else:
                    # Enumerate all values
                    result = subprocess.run(
                        ["reg", "query", reg_path], check=False, capture_output=True, text=True
                    )

                    if result.returncode == 0:
                        self.credentials["registry"].append(
                            {
                                "type": "registry_location",
                                "path": reg_path,
                                "note": "Contains potential credentials",
                            }
                        )

            except Exception as e:
                logger.debug(f"Error querying registry {reg_path}: {e}")

    # ===================
    # LINUX CREDENTIAL DISCOVERY
    # ===================

    def dump_linux_ssh_keys(self) -> None:
        """Discover SSH private keys."""
        logger.info("Discovering SSH keys...")
        self._audit_log("SSH key discovery started")

        ssh_dirs = [
            Path.home() / ".ssh",
            Path("/root/.ssh") if os.path.exists("/root/.ssh") else None,
        ]

        for ssh_dir in ssh_dirs:
            if ssh_dir is None or not ssh_dir.exists():
                continue

            try:
                for key_file in ssh_dir.iterdir():
                    if key_file.is_file():
                        # Check if it's a private key
                        try:
                            with open(key_file) as f:
                                content = f.read(100)  # Read first 100 chars

                                if "PRIVATE KEY" in content:
                                    self.credentials["ssh"].append(
                                        {
                                            "type": "ssh_private_key",
                                            "path": str(key_file),
                                            "filename": key_file.name,
                                            "permissions": oct(key_file.stat().st_mode)[-3:],
                                        }
                                    )

                        except PermissionError:
                            pass

            except PermissionError:
                logger.debug(f"Permission denied accessing {ssh_dir}")
            except Exception as e:
                logger.debug(f"Error scanning {ssh_dir}: {e}")

    def dump_linux_bash_history(self) -> None:
        """Search bash history for credentials."""
        logger.info("Searching bash history...")
        self._audit_log("Bash history search started")

        history_files = [
            Path.home() / ".bash_history",
            Path.home() / ".zsh_history",
            Path.home() / ".mysql_history",
            Path.home() / ".psql_history",
        ]

        credential_patterns = [
            r"password[=:\s]+['\"]?(\S+)",
            r"passwd[=:\s]+['\"]?(\S+)",
            r"api[_-]?key[=:\s]+['\"]?(\S+)",
            r"token[=:\s]+['\"]?(\S+)",
            r"mysql.*-p\s*(\S+)",
            r"psql.*password=(\S+)",
        ]

        for history_file in history_files:
            if not history_file.exists():
                continue

            try:
                with open(history_file, errors="ignore") as f:
                    lines = f.readlines()

                for line_num, line in enumerate(lines, 1):
                    for pattern in credential_patterns:
                        match = re.search(pattern, line, re.IGNORECASE)
                        if match:
                            self.credentials["history"].append(
                                {
                                    "type": "history_credential",
                                    "file": str(history_file),
                                    "line_number": line_num,
                                    "pattern": pattern,
                                    "context": line.strip()[:50] + "..."
                                    if len(line) > 50
                                    else line.strip(),
                                    "credential": "[REDACTED]",
                                }
                            )
                            break  # Only report first match per line

            except Exception as e:
                logger.debug(f"Error reading {history_file}: {e}")

    def dump_linux_config_files(self) -> None:
        """Search configuration files for credentials."""
        logger.info("Searching configuration files...")
        self._audit_log("Configuration file search started")

        config_locations = [
            Path.home() / ".aws" / "credentials",
            Path.home() / ".docker" / "config.json",
            Path("/etc/mysql") / "my.cnf",
            Path("/var/lib/postgresql") / ".pgpass",
            Path.home() / ".netrc",
            Path.home() / ".git-credentials",
        ]

        for config_file in config_locations:
            if not config_file.exists():
                continue

            try:
                # Just note the file exists (don't read sensitive content)
                self.credentials["config"].append(
                    {
                        "type": "config_file",
                        "path": str(config_file),
                        "permissions": oct(config_file.stat().st_mode)[-3:],
                        "note": "May contain credentials - review manually",
                    }
                )

            except Exception as e:
                logger.debug(f"Error checking {config_file}: {e}")

    def dump_linux_environment_variables(self) -> None:
        """Check environment variables for credentials."""
        logger.info("Checking environment variables...")
        self._audit_log("Environment variable check started")

        credential_env_vars = [
            "AWS_ACCESS_KEY_ID",
            "AWS_SECRET_ACCESS_KEY",
            "GITHUB_TOKEN",
            "DOCKER_PASSWORD",
            "DATABASE_PASSWORD",
            "API_KEY",
            "SECRET_KEY",
        ]

        for var_name in credential_env_vars:
            value = os.getenv(var_name)
            if value:
                self.credentials["config"].append(
                    {
                        "type": "environment_variable",
                        "variable": var_name,
                        "value": "[REDACTED]",
                        "length": len(value),
                    }
                )

    # ===================
    # MAIN OPERATIONS
    # ===================

    def dump_windows_all(self) -> None:
        """Run all Windows credential discovery."""
        self.dump_windows_saved_credentials()
        self.dump_windows_wifi_passwords()
        self.dump_windows_registry_credentials()

    def dump_linux_all(self) -> None:
        """Run all Linux credential discovery."""
        self.dump_linux_ssh_keys()
        self.dump_linux_bash_history()
        self.dump_linux_config_files()
        self.dump_linux_environment_variables()

    def get_summary(self) -> dict[str, Any]:
        """Generate summary of discovered credentials."""
        total_creds = sum(len(v) for v in self.credentials.values())

        return {
            "total_discovered": total_creds,
            "by_category": {k: len(v) for k, v in self.credentials.items()},
            "timestamp": datetime.now().isoformat(),
        }

    def save_results(self, output_path: Path, encrypt: bool = False) -> None:
        """
        Save discovered credentials to file.

        Args:
            output_path: Output file path
            encrypt: Whether to encrypt the output (recommended)
        """
        results = {
            "warning": "SENSITIVE DATA - Handle according to security policies",
            "scan_type": "Credential Discovery",
            "timestamp": datetime.now().isoformat(),
            "summary": self.get_summary(),
            "credentials": self.credentials,
        }

        try:
            with open(output_path, "w") as f:
                json.dump(results, f, indent=2)

            # Set restrictive permissions
            os.chmod(output_path, 0o600)

            logger.info(f"Results saved to {output_path} with restricted permissions")
            self._audit_log(f"Credentials saved to {output_path}")

        except Exception as e:
            logger.error(f"Error saving results: {e}")


def main() -> int:
    """Main entry point for command-line usage."""
    parser = argparse.ArgumentParser(
        description="Credential Dumper - Ethical Credential Discovery\n"
        "[!] EXTREMELY SENSITIVE - For authorized testing only\n"
        "[!] All operations are logged for audit",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument(
        "--os", required=True, choices=["windows", "linux"], help="Target operating system"
    )

    parser.add_argument(
        "--types",
        default="all",
        help="Credential types (comma-separated): all, saved, browser, wifi, ssh, history, config, registry",
    )

    parser.add_argument("--output", type=Path, help="Output file for discovered credentials (JSON)")

    parser.add_argument("--encrypt", action="store_true", help="Encrypt output file (recommended)")

    parser.add_argument("--config", help="Path to configuration file")

    args = parser.parse_args()

    # Load configuration
    config = load_config(args.config) if args.config else load_config()

    print("\n" + "=" * 70)
    print("[!] Credential Dumper - EXTREMELY SENSITIVE OPERATION")
    print("[!] For Authorized Security Testing Only")
    print("[!] All operations are logged for audit purposes")
    print("=" * 70 + "\n")

    print("[WARNING] This tool accesses sensitive credential data")
    print("[WARNING] Ensure you have explicit authorization")
    print("[WARNING] Review your organization's security policies\n")

    # Require confirmation
    response = input("Do you have authorization to proceed? (yes/no): ")
    if response.lower() != "yes":
        print("\n[-] Operation cancelled")
        return 1

    # Initialize dumper
    dumper = CredentialDumper(config)

    # Run discovery
    print(f"\n[*] Starting credential discovery for {args.os}...")

    types = args.types.split(",") if args.types != "all" else ["all"]

    if args.os == "windows":
        if "all" in types:
            dumper.dump_windows_all()
        else:
            for cred_type in types:
                cred_type = cred_type.strip()
                if cred_type == "saved":
                    dumper.dump_windows_saved_credentials()
                elif cred_type == "wifi":
                    dumper.dump_windows_wifi_passwords()
                elif cred_type == "registry":
                    dumper.dump_windows_registry_credentials()

    elif args.os == "linux":
        if "all" in types:
            dumper.dump_linux_all()
        else:
            for cred_type in types:
                cred_type = cred_type.strip()
                if cred_type == "ssh":
                    dumper.dump_linux_ssh_keys()
                elif cred_type == "history":
                    dumper.dump_linux_bash_history()
                elif cred_type == "config":
                    dumper.dump_linux_config_files()
                    dumper.dump_linux_environment_variables()

    # Get summary
    summary = dumper.get_summary()

    print("\n[+] Discovery Complete!")
    print(f"    Total Discovered: {summary['total_discovered']}")
    print("\n[+] By Category:")
    for category, count in summary["by_category"].items():
        if count > 0:
            print(f"    {category}: {count}")

    # Print findings (redacted)
    if summary["total_discovered"] > 0:
        print("\n[+] Findings Summary:\n")

        for category, findings in dumper.credentials.items():
            if findings:
                print(f"  [{category.upper()}]: {len(findings)} items")
                for finding in findings[:3]:  # Show first 3
                    print(f"    - {finding.get('type', 'unknown')}")
                    if "path" in finding:
                        print(f"      Path: {finding['path']}")
                    elif "ssid" in finding:
                        print(f"      SSID: {finding['ssid']}")
                if len(findings) > 3:
                    print(f"    ... and {len(findings) - 3} more")
                print()

    # Save results
    if args.output:
        dumper.save_results(args.output, args.encrypt)
        print(f"\n[+] Results saved to {args.output}")
        print("[!] File permissions set to 0600 (owner read/write only)")
        print("[!] Handle this file according to your security policies")

    print("\n[!] REMINDER: All operations have been logged for audit")

    return 0


if __name__ == "__main__":
    sys.exit(main())
