#!/usr/bin/env python3
"""
Persistence Module - Establish and Detect Persistence Mechanisms

Tests and demonstrates persistence techniques for authorized red team operations.

[!] AUTHORIZATION REQUIRED: Only use on authorized systems.
[!] ETHICAL USE ONLY: For defensive training and authorized security testing.

Usage:
    python persistence.py --check windows
    python persistence.py --install windows scheduled-task --command "cmd.exe" --cleanup

Examples:
    # Check existing persistence mechanisms
    python persistence.py --check windows
    python persistence.py --check linux

    # Install persistence (with cleanup)
    python persistence.py --install windows scheduled-task \\
        --name "SystemUpdate" --command "powershell.exe -w hidden -c whoami" --cleanup

    # List installed persistence mechanisms
    python persistence.py --list

    # Cleanup all installed persistence
    python persistence.py --cleanup-all

Author: David Dashti
Date: 2025-10-15
MITRE ATT&CK: T1053 (Scheduled Task/Job), T1547 (Boot/Logon Autostart), T1098 (Account Manipulation)
"""

import argparse
import sys
import platform
import subprocess
import os
import json
from pathlib import Path
from typing import Dict, Any, List, Optional
from datetime import datetime

from utils.logger import get_logger
from utils.config import load_config

logger = get_logger(__name__)


class PersistenceManager:
    """
    Manage persistence mechanisms for Windows and Linux.

    Supports installation, detection, and cleanup of persistence.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None) -> None:
        """Initialize persistence manager."""
        self.config = config or load_config()
        self.os_type = platform.system().lower()
        self.installed_persistence = []
        self.persistence_log = Path(".persistence_log.json")

        # Load existing persistence log
        self._load_persistence_log()

        logger.info(f"Initialized PersistenceManager for {self.os_type}")

    def _load_persistence_log(self) -> None:
        """Load persistence log from disk."""
        if self.persistence_log.exists():
            try:
                with open(self.persistence_log, "r") as f:
                    self.installed_persistence = json.load(f)
                logger.info(f"Loaded {len(self.installed_persistence)} persisten mechanisms from log")
            except Exception as e:
                logger.error(f"Error loading persistence log: {e}")

    def _save_persistence_log(self) -> None:
        """Save persistence log to disk."""
        try:
            with open(self.persistence_log, "w") as f:
                json.dump(self.installed_persistence, f, indent=2)
            logger.info("Saved persistence log")
        except Exception as e:
            logger.error(f"Error saving persistence log: {e}")

    def _add_to_log(self, method: str, details: Dict[str, Any]) -> None:
        """Add persistence mechanism to log."""
        entry = {
            "method": method,
            "os": self.os_type,
            "installed": datetime.now().isoformat(),
            "details": details
        }
        self.installed_persistence.append(entry)
        self._save_persistence_log()

    # ===================
    # WINDOWS PERSISTENCE
    # ===================

    def check_windows_persistence(self) -> List[Dict[str, Any]]:
        """
        Check for common Windows persistence mechanisms.

        Returns:
            List of detected persistence mechanisms
        """
        logger.info("Checking Windows persistence mechanisms...")

        findings = []

        # Check scheduled tasks
        findings.extend(self._check_windows_scheduled_tasks())

        # Check registry run keys
        findings.extend(self._check_windows_registry_run_keys())

        # Check startup folder
        findings.extend(self._check_windows_startup_folder())

        # Check services
        findings.extend(self._check_windows_services())

        logger.info(f"Found {len(findings)} Windows persistence mechanisms")
        return findings

    def _check_windows_scheduled_tasks(self) -> List[Dict[str, Any]]:
        """Check for scheduled tasks."""
        findings = []

        try:
            result = subprocess.run(
                ["schtasks", "/query", "/fo", "LIST", "/v"],
                capture_output=True,
                text=True
            )

            if result.returncode == 0:
                # Parse output for suspicious tasks
                lines = result.stdout.split("\n")
                current_task = {}

                for line in lines:
                    line = line.strip()

                    if line.startswith("TaskName:"):
                        if current_task:
                            findings.append(current_task)
                        current_task = {
                            "type": "scheduled_task",
                            "name": line.split(":", 1)[1].strip()
                        }
                    elif line.startswith("Task To Run:") and current_task:
                        current_task["command"] = line.split(":", 1)[1].strip()
                    elif line.startswith("Status:") and current_task:
                        current_task["status"] = line.split(":", 1)[1].strip()

                if current_task:
                    findings.append(current_task)

        except Exception as e:
            logger.error(f"Error checking scheduled tasks: {e}")

        return findings[:10]  # Limit output

    def _check_windows_registry_run_keys(self) -> List[Dict[str, Any]]:
        """Check registry run keys."""
        findings = []

        # Common registry run keys
        run_keys = [
            r"HKCU\Software\Microsoft\Windows\CurrentVersion\Run",
            r"HKLM\Software\Microsoft\Windows\CurrentVersion\Run",
            r"HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce",
            r"HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce",
        ]

        for key in run_keys:
            try:
                result = subprocess.run(
                    ["reg", "query", key],
                    capture_output=True,
                    text=True
                )

                if result.returncode == 0:
                    lines = result.stdout.split("\n")[1:]  # Skip header

                    for line in lines:
                        if line.strip() and "REG_SZ" in line:
                            parts = line.split("REG_SZ")
                            if len(parts) == 2:
                                name = parts[0].strip()
                                value = parts[1].strip()

                                findings.append({
                                    "type": "registry_run_key",
                                    "key": key,
                                    "name": name,
                                    "value": value
                                })

            except Exception as e:
                logger.debug(f"Error checking {key}: {e}")

        return findings

    def _check_windows_startup_folder(self) -> List[Dict[str, Any]]:
        """Check startup folder."""
        findings = []

        startup_paths = [
            Path(os.path.expandvars(r"%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup")),
            Path(os.path.expandvars(r"%PROGRAMDATA%\Microsoft\Windows\Start Menu\Programs\Startup"))
        ]

        for startup_path in startup_paths:
            if startup_path.exists():
                for item in startup_path.iterdir():
                    findings.append({
                        "type": "startup_folder",
                        "path": str(startup_path),
                        "file": item.name
                    })

        return findings

    def _check_windows_services(self) -> List[Dict[str, Any]]:
        """Check for non-Microsoft services."""
        findings = []

        try:
            result = subprocess.run(
                ["sc", "query", "type=", "service"],
                capture_output=True,
                text=True
            )

            if result.returncode == 0:
                lines = result.stdout.split("\n")
                current_service = {}

                for line in lines:
                    line = line.strip()

                    if line.startswith("SERVICE_NAME:"):
                        if current_service:
                            findings.append(current_service)
                        current_service = {
                            "type": "service",
                            "name": line.split(":", 1)[1].strip()
                        }
                    elif line.startswith("STATE") and current_service:
                        current_service["state"] = line.split(":", 1)[1].strip()

                if current_service:
                    findings.append(current_service)

        except Exception as e:
            logger.error(f"Error checking services: {e}")

        return findings[:10]  # Limit output

    def install_windows_persistence(
        self,
        method: str,
        name: str,
        command: str,
        **kwargs
    ) -> bool:
        """
        Install Windows persistence mechanism.

        Args:
            method: Persistence method (scheduled-task, registry, service)
            name: Persistence name/identifier
            command: Command to execute
            **kwargs: Additional method-specific parameters

        Returns:
            True if successful
        """
        if method == "scheduled-task":
            return self._install_windows_scheduled_task(name, command, **kwargs)
        elif method == "registry":
            return self._install_windows_registry(name, command, **kwargs)
        else:
            logger.error(f"Unknown Windows persistence method: {method}")
            return False

    def _install_windows_scheduled_task(
        self,
        name: str,
        command: str,
        trigger: str = "ONLOGON"
    ) -> bool:
        """Install scheduled task persistence."""
        try:
            # Create scheduled task
            cmd = [
                "schtasks", "/create",
                "/tn", name,
                "/tr", command,
                "/sc", trigger,
                "/f"  # Force overwrite
            ]

            result = subprocess.run(cmd, capture_output=True, text=True)

            if result.returncode == 0:
                logger.info(f"Created scheduled task: {name}")

                self._add_to_log("scheduled_task", {
                    "name": name,
                    "command": command,
                    "trigger": trigger
                })

                return True
            else:
                logger.error(f"Failed to create scheduled task: {result.stderr}")
                return False

        except Exception as e:
            logger.error(f"Error creating scheduled task: {e}")
            return False

    def _install_windows_registry(
        self,
        name: str,
        command: str,
        key: str = r"HKCU\Software\Microsoft\Windows\CurrentVersion\Run"
    ) -> bool:
        """Install registry run key persistence."""
        try:
            cmd = [
                "reg", "add", key,
                "/v", name,
                "/t", "REG_SZ",
                "/d", command,
                "/f"
            ]

            result = subprocess.run(cmd, capture_output=True, text=True)

            if result.returncode == 0:
                logger.info(f"Created registry run key: {name}")

                self._add_to_log("registry_run_key", {
                    "name": name,
                    "key": key,
                    "command": command
                })

                return True
            else:
                logger.error(f"Failed to create registry key: {result.stderr}")
                return False

        except Exception as e:
            logger.error(f"Error creating registry key: {e}")
            return False

    # ===================
    # LINUX PERSISTENCE
    # ===================

    def check_linux_persistence(self) -> List[Dict[str, Any]]:
        """
        Check for common Linux persistence mechanisms.

        Returns:
            List of detected persistence mechanisms
        """
        logger.info("Checking Linux persistence mechanisms...")

        findings = []

        # Check cron jobs
        findings.extend(self._check_linux_cron())

        # Check systemd services
        findings.extend(self._check_linux_systemd())

        # Check authorized_keys
        findings.extend(self._check_linux_ssh_keys())

        # Check bashrc/profile
        findings.extend(self._check_linux_shell_profiles())

        logger.info(f"Found {len(findings)} Linux persistence mechanisms")
        return findings

    def _check_linux_cron(self) -> List[Dict[str, Any]]:
        """Check cron jobs."""
        findings = []

        try:
            # User crontab
            result = subprocess.run(
                ["crontab", "-l"],
                capture_output=True,
                text=True
            )

            if result.returncode == 0:
                for line in result.stdout.split("\n"):
                    if line.strip() and not line.startswith("#"):
                        findings.append({
                            "type": "cron_user",
                            "entry": line.strip()
                        })

        except Exception as e:
            logger.debug(f"Error checking user crontab: {e}")

        # System crontab
        cron_dirs = ["/etc/cron.d", "/etc/cron.daily", "/etc/cron.hourly"]

        for cron_dir in cron_dirs:
            cron_path = Path(cron_dir)
            if cron_path.exists():
                for item in cron_path.iterdir():
                    findings.append({
                        "type": "cron_system",
                        "path": str(item)
                    })

        return findings

    def _check_linux_systemd(self) -> List[Dict[str, Any]]:
        """Check systemd services."""
        findings = []

        try:
            result = subprocess.run(
                ["systemctl", "list-units", "--type=service", "--all"],
                capture_output=True,
                text=True
            )

            if result.returncode == 0:
                lines = result.stdout.split("\n")[1:]  # Skip header

                for line in lines:
                    if ".service" in line:
                        parts = line.split()
                        if parts:
                            findings.append({
                                "type": "systemd_service",
                                "name": parts[0],
                                "state": parts[1] if len(parts) > 1 else "unknown"
                            })

        except Exception as e:
            logger.debug(f"Error checking systemd services: {e}")

        return findings[:10]  # Limit output

    def _check_linux_ssh_keys(self) -> List[Dict[str, Any]]:
        """Check SSH authorized_keys."""
        findings = []

        authorized_keys = Path.home() / ".ssh" / "authorized_keys"

        if authorized_keys.exists():
            try:
                with open(authorized_keys, "r") as f:
                    lines = f.readlines()

                for i, line in enumerate(lines, 1):
                    if line.strip() and not line.startswith("#"):
                        findings.append({
                            "type": "ssh_authorized_key",
                            "line": i,
                            "key": line.strip()[:50] + "..."
                        })

            except Exception as e:
                logger.error(f"Error reading authorized_keys: {e}")

        return findings

    def _check_linux_shell_profiles(self) -> List[Dict[str, Any]]:
        """Check shell profile files."""
        findings = []

        profile_files = [
            Path.home() / ".bashrc",
            Path.home() / ".bash_profile",
            Path.home() / ".profile",
            Path.home() / ".zshrc"
        ]

        for profile_file in profile_files:
            if profile_file.exists():
                findings.append({
                    "type": "shell_profile",
                    "file": str(profile_file)
                })

        return findings

    def install_linux_persistence(
        self,
        method: str,
        name: str,
        command: str,
        **kwargs
    ) -> bool:
        """
        Install Linux persistence mechanism.

        Args:
            method: Persistence method (cron, systemd, ssh-key, profile)
            name: Persistence name/identifier
            command: Command to execute
            **kwargs: Additional method-specific parameters

        Returns:
            True if successful
        """
        if method == "cron":
            return self._install_linux_cron(name, command, **kwargs)
        elif method == "profile":
            return self._install_linux_profile(name, command, **kwargs)
        else:
            logger.error(f"Unknown Linux persistence method: {method}")
            return False

    def _install_linux_cron(
        self,
        name: str,
        command: str,
        schedule: str = "@reboot"
    ) -> bool:
        """Install cron job persistence."""
        try:
            # Get existing crontab
            result = subprocess.run(
                ["crontab", "-l"],
                capture_output=True,
                text=True
            )

            existing_cron = result.stdout if result.returncode == 0 else ""

            # Add new entry
            new_entry = f"{schedule} {command}  # {name}\n"
            updated_cron = existing_cron + new_entry

            # Install updated crontab
            process = subprocess.Popen(
                ["crontab", "-"],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )

            stdout, stderr = process.communicate(input=updated_cron)

            if process.returncode == 0:
                logger.info(f"Created cron job: {name}")

                self._add_to_log("cron", {
                    "name": name,
                    "command": command,
                    "schedule": schedule
                })

                return True
            else:
                logger.error(f"Failed to create cron job: {stderr}")
                return False

        except Exception as e:
            logger.error(f"Error creating cron job: {e}")
            return False

    def _install_linux_profile(
        self,
        name: str,
        command: str,
        profile_file: str = "~/.bashrc"
    ) -> bool:
        """Install shell profile persistence."""
        try:
            profile_path = Path(profile_file).expanduser()

            # Append to profile
            with open(profile_path, "a") as f:
                f.write(f"\n# {name}\n")
                f.write(f"{command}\n")

            logger.info(f"Added to {profile_path}: {name}")

            self._add_to_log("shell_profile", {
                "name": name,
                "file": str(profile_path),
                "command": command
            })

            return True

        except Exception as e:
            logger.error(f"Error modifying profile: {e}")
            return False

    # ===================
    # CLEANUP
    # ===================

    def cleanup_persistence(self, entry: Dict[str, Any]) -> bool:
        """
        Remove installed persistence mechanism.

        Args:
            entry: Persistence log entry

        Returns:
            True if successful
        """
        method = entry["method"]
        details = entry["details"]

        logger.info(f"Cleaning up {method}: {details.get('name')}")

        if method == "scheduled_task":
            return self._cleanup_windows_scheduled_task(details["name"])
        elif method == "registry_run_key":
            return self._cleanup_windows_registry(details["name"], details["key"])
        elif method == "cron":
            return self._cleanup_linux_cron(details["name"])
        else:
            logger.warning(f"No cleanup method for {method}")
            return False

    def _cleanup_windows_scheduled_task(self, name: str) -> bool:
        """Remove scheduled task."""
        try:
            result = subprocess.run(
                ["schtasks", "/delete", "/tn", name, "/f"],
                capture_output=True,
                text=True
            )

            return result.returncode == 0

        except Exception as e:
            logger.error(f"Error removing scheduled task: {e}")
            return False

    def _cleanup_windows_registry(self, name: str, key: str) -> bool:
        """Remove registry run key."""
        try:
            result = subprocess.run(
                ["reg", "delete", key, "/v", name, "/f"],
                capture_output=True,
                text=True
            )

            return result.returncode == 0

        except Exception as e:
            logger.error(f"Error removing registry key: {e}")
            return False

    def _cleanup_linux_cron(self, name: str) -> bool:
        """Remove cron job."""
        try:
            # Get existing crontab
            result = subprocess.run(
                ["crontab", "-l"],
                capture_output=True,
                text=True
            )

            if result.returncode != 0:
                return False

            # Filter out the entry
            lines = result.stdout.split("\n")
            filtered_lines = [line for line in lines if f"# {name}" not in line and name not in line]

            updated_cron = "\n".join(filtered_lines)

            # Install updated crontab
            process = subprocess.Popen(
                ["crontab", "-"],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )

            stdout, stderr = process.communicate(input=updated_cron)

            return process.returncode == 0

        except Exception as e:
            logger.error(f"Error removing cron job: {e}")
            return False

    def cleanup_all(self) -> int:
        """
        Cleanup all installed persistence mechanisms.

        Returns:
            Number of mechanisms cleaned up
        """
        count = 0

        for entry in self.installed_persistence[:]:  # Copy list
            if self.cleanup_persistence(entry):
                self.installed_persistence.remove(entry)
                count += 1

        self._save_persistence_log()
        return count


def main() -> int:
    """Main entry point for command-line usage."""
    parser = argparse.ArgumentParser(
        description="Persistence Module - Establish and Detect Persistence\n"
                    "[!] For authorized security testing only",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument(
        "--check",
        choices=["windows", "linux"],
        help="Check for existing persistence mechanisms"
    )

    parser.add_argument(
        "--install",
        nargs=2,
        metavar=("OS", "METHOD"),
        help="Install persistence (e.g., --install windows scheduled-task)"
    )

    parser.add_argument(
        "--name",
        help="Name/identifier for persistence mechanism"
    )

    parser.add_argument(
        "--command",
        help="Command to execute"
    )

    parser.add_argument(
        "--list",
        action="store_true",
        help="List installed persistence mechanisms"
    )

    parser.add_argument(
        "--cleanup-all",
        action="store_true",
        help="Cleanup all installed persistence"
    )

    parser.add_argument(
        "--config",
        help="Path to configuration file"
    )

    args = parser.parse_args()

    # Load configuration
    config = load_config(args.config) if args.config else load_config()

    print("\n" + "=" * 70)
    print("[!] Persistence Module - For Authorized Security Testing Only")
    print("=" * 70 + "\n")

    # Initialize manager
    manager = PersistenceManager(config)

    # Check persistence
    if args.check:
        if args.check == "windows":
            findings = manager.check_windows_persistence()
        else:
            findings = manager.check_linux_persistence()

        print(f"[+] Found {len(findings)} persistence mechanisms:\n")

        for finding in findings:
            print(f"Type: {finding.get('type')}")
            for key, value in finding.items():
                if key != "type":
                    print(f"  {key}: {value}")
            print()

        return 0

    # Install persistence
    elif args.install:
        os_type, method = args.install

        if not args.name or not args.command:
            print("[-] Error: --name and --command required for installation")
            return 1

        if os_type == "windows":
            success = manager.install_windows_persistence(method, args.name, args.command)
        elif os_type == "linux":
            success = manager.install_linux_persistence(method, args.name, args.command)
        else:
            print(f"[-] Unknown OS: {os_type}")
            return 1

        if success:
            print(f"[+] Installed {method} persistence: {args.name}")
            return 0
        else:
            print(f"[-] Failed to install persistence")
            return 1

    # List installed
    elif args.list:
        if not manager.installed_persistence:
            print("[*] No installed persistence mechanisms found")
            return 0

        print(f"[+] Installed Persistence ({len(manager.installed_persistence)}):\n")

        for i, entry in enumerate(manager.installed_persistence, 1):
            print(f"{i}. {entry['method']} - {entry['details'].get('name')}")
            print(f"   OS: {entry['os']}")
            print(f"   Installed: {entry['installed']}")
            print()

        return 0

    # Cleanup all
    elif args.cleanup_all:
        count = manager.cleanup_all()
        print(f"[+] Cleaned up {count} persistence mechanisms")
        return 0

    # No action
    parser.print_help()
    return 0


if __name__ == "__main__":
    sys.exit(main())
